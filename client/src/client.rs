use crate::{utils, Error, Result};
use borsh::BorshSerialize;
use solana_client::rpc_client::RpcClient;
use solana_sdk::{
    commitment_config::CommitmentConfig,
    instruction::{AccountMeta, Instruction},
    message::Message, pubkey::Pubkey, signature::Signer,
    signer::keypair::{read_keypair_file, Keypair}, transaction::Transaction,
};

/// Establishes a RPC connection with the solana cluster configured by
/// `solana config set --url <URL>`. Information about what cluster
/// has been configured is gleened from the solana config file
/// `~/.config/solana/cli/config.yml`.
pub fn establish_connection(url: &Option<String>, config: &Option<String>) -> Result<RpcClient> {
    let rpc_url = match url {
        Some(x) => {
            if x == "localhost" {
                "http://localhost:8899".to_string()
            } else {
                String::from(x)
            }
        },
        None => utils::get_rpc_url(config)?
    };
    Ok(RpcClient::new_with_commitment(rpc_url, CommitmentConfig::confirmed()))
}

/// Determines the amount of lamports that will be required to execute
/// this smart contract. The minimum balance is calculated assuming
/// that the user would like to make their account rent exempt.
pub fn get_balance_requirement(connection: &RpcClient) -> Result<u64> {
    let account_fee =
        connection.get_minimum_balance_for_rent_exemption(utils::get_object_data_size()?)?;
    let (_, fee_calculator) = connection.get_recent_blockhash()?;
    let transaction_fee = fee_calculator.lamports_per_signature * 100;
    Ok(transaction_fee + account_fee)
}

/// Gets the balance of PAYER in lamports via an RPC call over CONNECTION.
pub fn get_payer_balance(payer: &Keypair, connection: &RpcClient) -> Result<u64> {
    Ok(connection.get_balance(&payer.pubkey())?)
}

/// Requests that AMOUNT lamports are transfered to PLAYER via a RPC call over CONNECTION.
pub fn request_airdrop(player: &Keypair, connection: &RpcClient, amount: u64) -> Result<()> {
    let sig = connection.request_airdrop(&player.pubkey(), amount)?;
    loop {
        let confirmed = connection.confirm_transaction(&sig)?;
        if confirmed {
            break;
        }
    }
    Ok(())
}

/// Loads keypair information from the file located at KEYPAIR_PATH
/// and then verifies that the loaded keypair information corresponds
/// to an executable account via CONNECTION. Failure to read the
/// keypair or the loaded keypair corresponding to an executable
/// account will result in an error being returned.
pub fn get_program(keypair_path: &str, connection: &RpcClient) -> Result<Keypair> {
    let program_keypair = read_keypair_file(keypair_path).map_err(|e| {
        Error::InvalidConfig(format!(
            "failed to read program keypair file ({}): ({})",
            keypair_path, e
        ))
    })?;

    let program_info = connection.get_account(&program_keypair.pubkey())?;
    if !program_info.executable {
        return Err(Error::InvalidConfig(format!(
            "program with keypair ({}) is not executable",
            keypair_path
        )));
    }

    Ok(program_keypair)
}

/// On Solana accounts are ways to store data. We create an object
/// account which we subsequentally transfer ownership of to the
/// program. This allows the program to write to that account as it
/// deems fit.
///
/// The object account has a derived address
/// (https://docs.solana.com/developing/programming-model/calling-between-programs#program-derived-addresses)
/// which allows it to own and manage the account. Additionally the
/// address being derived means that we can regenerate it when we'd
/// like to find the object account again later.
pub fn create_object_account(
    payer: &Keypair,
    seed: &str,
    program: &Keypair,
    connection: &RpcClient,
) -> Result<()> {
    let object_account_pubkey =
        utils::get_object_account_public_key(&payer.pubkey(), seed, &program.pubkey())?;
    if let Err(_) = connection.get_account(&object_account_pubkey) {
        let lamport_requirement =
            connection.get_minimum_balance_for_rent_exemption(
                utils::get_object_data_size()?)?;

        // This instruction creates an account with the key
        // "object_account_pubkey". The created account is owned by the
        // program. The account is loaded with enough lamports to stop
        // it from needing to pay rent. The lamports to fund this are
        // paid by the payer.
        //
        // It is important that the program owns the created account
        // because it needs to be able to modify its contents.
        //
        // The address of the account created by
        // create_account_with_seed is the same as the address
        // generated by utils::get_object_account_public_key. We do
        // this as opposed to create_account because create account
        // doesn't derive that address like that.
        let instruction = solana_sdk::system_instruction::create_account_with_seed(
            &payer.pubkey(),
            &object_account_pubkey,
            &payer.pubkey(),
            seed,
            lamport_requirement + 1000,
            utils::get_object_data_size()? as u64,
            &program.pubkey(),
        );
        let message = Message::new(&[instruction], Some(&payer.pubkey()));
        let transaction =
            Transaction::new(&[payer], message, connection.get_latest_blockhash()?);
        connection.send_and_confirm_transaction(&transaction)?;
    }
    Ok(())
}

/// Sends an instruction from PLAYER to PROGRAM via CONNECTION. The
/// instruction contains ENTRY operation, and color components. It
/// also contains the address of our previously generated object
/// account. The program will use that passed in address to update the
/// object after verifying that it owns the account that we have
/// passed in.
pub fn create_color_object(
    payer: &Keypair,
    seed: &str,
    red: u8,
    green: u8,
    blue: u8,
    program: &Keypair,
    connection: &RpcClient
) -> Result<()> {
    #[derive(BorshSerialize)]
    struct Params<'a> {
        entry: &'a str,
        red: u8,
        green: u8,
        blue: u8,
    }
    let data = Params {
        entry: "create",
        red,
        green,
        blue,
    }
    .try_to_vec()
    .map_err(|e| Error::SerializationError(e))?;
    let object_account_pubkey = utils::get_object_account_public_key(&payer.pubkey(), seed, &program.pubkey())?;
    let instruction = Instruction::new_with_bytes(
        program.pubkey(),
        &data,
        vec![
            AccountMeta::new(object_account_pubkey, false),
        ],
    );
    let message = Message::new(&[instruction], Some(&payer.pubkey()));
    let transaction = Transaction::new(&[payer], message, connection.get_latest_blockhash()?);
    // Submit an instruction to the chain which tells the program to
    // run. We pass the account that we want the results to be stored
    // in as one of the account arguments which the program will handle.
    connection.send_and_confirm_transaction(&transaction)?;
    Ok(())
}

pub fn transfer_color_object(
    payer: &Keypair,
    receiver_seed: &str,
    sender_seed: &str,
    program: &Keypair,
    connection: &RpcClient
) -> Result<()> {
    #[derive(BorshSerialize)]
    struct Params<'a> {
        entry: &'a str,
    }
    let data = Params {
        entry: "transfer",
    }
    .try_to_vec()
    .map_err(|e| Error::SerializationError(e))?;
    let receiver_pubkey = utils::get_object_account_public_key(
        &payer.pubkey(),
        receiver_seed,
        &program.pubkey(),
    )?;
    let sender_pubkey = utils::get_object_account_public_key(
        &payer.pubkey(),
        sender_seed,
        &program.pubkey(),
    )?;
    let instruction = Instruction::new_with_bytes(
        program.pubkey(),
        &data,
        vec![
            AccountMeta::new(receiver_pubkey, false),
            AccountMeta::new(sender_pubkey, false),
        ],
    );
    let message = Message::new(&[instruction], Some(&payer.pubkey()));
    let transaction = Transaction::new(&[payer], message, connection.get_latest_blockhash()?);
    connection.send_and_confirm_transaction(&transaction)?;
    Ok(())
}

pub fn dump_account(msg: &str, account_pubkey: &Pubkey, connection: &RpcClient) -> Result<()> {
    let account = connection.get_account(account_pubkey).unwrap();
    println!("{}: Pubkey {} {:?}", msg, account_pubkey,  account);
    Ok(())
}
